#PARSER#
name1
**R

  x <- c(1:10)
  print(x)
**/

# This is a comment yup

module2
**python

x = 3
print(x)
**/

moduu
**R
  x <- c(1:10)
  y <- x^2
  print(y)
  print(x)
**/

rtester
**R
  args <- commandArgs(trailingOnly = TRUE)
  
  qwe <- function(asd){
    return(as.integer(asd)^2)
  }
  qwe(args[1]) 
**/

luaTest
**lua
function fact (n)
    if n == 0 then
      return 1
    else
      return n * fact(n-1)
    end
  end
  
--print("enter a number:")
  --a = io.read("*number")
  print(fact(arg[1]))
--If you are using Lua 

**/

goMod
**go
  package main
  import "os"
  import "fmt"
  func main() {
      arg := os.Args[1]
      fmt.Println(arg)
  }
**/

testElixir
**Elixir
  IO.puts "Hello world from Elixir"
**/

testBat
**bat
echo hi
echo hi again

**/

testRust
**rust
fn main() {
    // The statements here will be executed when the compiled binary is called

    // Print text to the console
    println!("Hello World! from rust");
}
**/

testRuby
**ruby
puts "Hello World From Ruby!"
puts ARGV[0]*3

**/

testPerl
**perl
print "Hello, world!\n";
print qq=Did you say "Hello?"\n=;
print "$ARGV[0]\n";
**/

testDart
**dart
void main() {
  print('Hello, World! from dart');
}
**/

# Testing function calls here

** testDart
** testPerl 3
** name1 
** module2
** rtester 4


** luaTest 7
** goMod 4
** testElixir
** testBat
** testRust
** testRuby 4

# Testing pipe calls here
rtester **<< module2
testRuby **<< module2
goMod **<< module2
luaTest **<< module2

moduleFun
**js
**/